var diceNumber = 2;

var firstCat = {
  name: 'Кекс',
  points: 0
};

var secondCat = {
  name: 'Рудольф',
  points: 0
};

var runGame = function (quantity, firstPlayer, secondPlayer) {
  firstPlayer.points += keks.throwDice(quantity, quantity * 6);
  secondPlayer.points += keks.throwDice(quantity, quantity * 6);
  console.log(firstPlayer.name + ' выбросил ' + firstPlayer.points);
  console.log(secondPlayer.name + ' выбросил ' + secondPlayer.points);
};

runGame(diceNumber, firstCat, secondCat);
/////////////////////////////////////////////////////////////////////////
/*С помощью объектов мы удобно описали игроков и теперь используем эти данные в функции. Параметров стало меньше, но снова возникает вопрос о росте количества участников игры. Что делать, если их станет десять? Создавать ещё объекты? Да! Но есть два минуса:

Число параметров будет расти вместе с числом игроков.
Код в теле функции будет раздуваться, ведь для каждого игрока есть строчка с увеличением очков и выводом результатов в консоль. Чем больше игроков, тем больше кода будет в функции.
Было бы здорово написать код функции так, чтобы она работала для любого количества игроков. Есть ли такая структура, которая может хранить в себе много данных и которую удобно обрабатывать? Да! Массивы! И вы с ними уже знакомы!

Вот краткое напоминание на всякий случай: массив — список элементов. У каждого из них есть порядковый номер. Массивы и чтение из них выглядят так:

// Массив чисел
var array = [10, 20, 30, 40, 50];

// Читаем элементы из массива по индексу (порядковому номеру)
console.log(array[0]); // Выведет 10
console.log(array[3]); // Выведет 40
Если вы совсем забыли, что такое массивы и как они работают, пройдите курс «Массивы».

Вернёмся к нашей задаче и введём массив с объектами игроков. Будем передавать в функцию именно его. Тогда мы сможем перебирать массив в цикле и для каждого игрока делать одно и то же: бросать кубики, записывать результат и показывать его.*/